rules_version = '2';

function isAuthenticated() {
  return request.auth.uid != null;
}

function isUser(id) {
  return isAuthenticated() && request.auth.uid == id;
}

function isVerifiedCAV() {
  // TODO: Actually use auth claims
  return isAuthenticated() && true;
}

function isVerifiedPIN() {
  // TODO: Actually use auth claims
  return isAuthenticated() && true;
}

function currentUserIsCurrentPINRef(userID, database, data) {
  return ('pinUserRef' in data) &&
  data.pinUserRef == /databases/$(database)/documents/users/$(userID)
}

function currentUserIsCurrentCAVRef(userID, database, data) {
  return isAuthenticated() &&
  ('cavUserRef' in data) &&
  data.cavUserRef == /databases/$(database)/documents/users/$(userID)
}

function questionnaireBelongsToUser(userID, database, data) {
    return isAuthenticated() &&
           ('parentRef' in data) &&
           data.parentRef == /databases/$(database)/documents/users/$(userID)
}

function confirmEitherPINorCAV(userID, database, data) {
    return currentUserIsCurrentPINRef(userID, database, data) || currentUserIsCurrentCAVRef(userID, database, data)
}

function isNotSameCAVPIN(data) {
  return data.cavUserRef != data.pinUserRef
}

function verifyUserDataComplete(data) {
   return data.averageRating >= 1 &&
          data.casesCompleted >= 0 &&
          data.requestsMade >= 0 &&
          ('username' in data)
}

function verifyQuestionnaireComplete(data) {
   return ('parentRef' in data) &&
          ('data' in data) &&
          ('type' in data) &&
          ('createdAt' in data) &&
          ('version' in data)
}

// Completed requests need ratings on all sides
function verifyHelpRequestAttributesForStatus(status, data) {
    // No if/else so we have to do this
    return (
             status == 'ongoing' && ('cavUserRef' in data)
           ) ||
           (
             (status == 'completed') &&
             ('cavUserRef' in data) &&
             ('pinRating' in data) &&
             ('cavRating' in data) &&
             ('pinRatedAt' in data) &&
             ('cavRatedAt' in data)
           ) ||
           true // for other statuses we don't have extra requirements
}

function verifyHelpRequestDataComplete(data) {
   return ('pinUserRef' in data) &&
          ('pinUserSnapshot' in data) &&
          ('title' in data) &&
          ('description' in data) &&
          ('latLng' in data) &&
          ('status' in data) &&
          ('createdAt' in data) &&
          ('updatedAt' in data) &&
          verifyHelpRequestAttributesForStatus(data.status, data)
}

function verifyOfferDataComplete(data) {
   return ('cavUserRef' in data) &&
          ('pinUserRef' in data) &&
          ('requestRef' in data) &&
          ('cavUserSnapshot' in data) &&
          ('message' in data) &&
          ('status' in data) &&
          ('createdAt' in data)
}

// TODO: Further validate address object.
function verifyUserPrivilegedInformationDataComplete(data) {
   return ('address' in data) &&
          ('termsAccepted' in data) &&
          ('termsVersion' in data)
}

service cloud.firestore {
  match /databases/{database}/documents {
    // Catch all -- Dont read/write to collections without rules
    match /{document=**} {
      allow read, write: if false;
    }

    match /users/{userID} {
      // Anyone can read your profile
      allow read: if isAuthenticated();
      // Only you can edit your own profile
      allow write: if isUser(userID) && verifyUserDataComplete(request.resource.data);
    }

    // 1: Read + Writes to sub-collection can only be done by the owner
    // 2: Writes to sub-collections must match userID chain so we can always directly reference
    match /users/{userID}/privilegedInformation/{subDocID} {
        allow read: if isUser(userID) && userID == subDocID;
        allow write: if isUser(userID) && userID == subDocID && verifyUserPrivilegedInformationDataComplete(request.resource.data);
    }

    match /offers/{offerID} {
      // Only the PIN or CAV of the request can read the offers
      allow list: if (isVerifiedCAV() || isVerifiedPIN()) && confirmEitherPINorCAV(request.auth.uid, database, resource.data)
      allow get: if resource.data.pinUserRef == /databases/$(database)/documents/users/$(request.auth.uid) || resource.data.cavUserRef == /databases/$(database)/documents/users/$(request.auth.uid)
      // Only CAVs can submit offers (as themselves)
      allow write: if isVerifiedCAV() &&
       currentUserIsCurrentCAVRef(request.auth.uid, database, request.resource.data) &&
       verifyOfferDataComplete(request.resource.data);
    }

    match /requests/{reqID} {
      // Only CAVs can see requests
      allow read: if isVerifiedCAV() || isVerifiedPIN();
      allow write: if isVerifiedPIN() &&
       isNotSameCAVPIN(request.resource.data) &&
       verifyHelpRequestDataComplete(request.resource.data);
    }

    match /questionnaires/{questID} {
      // Can only read + write my own data
      allow read: if isAuthenticated() && questionnaireBelongsToUser(request.auth.uid, database, resource.data);
      // TODO: Change this rule once we allow other entities to submit questionnaires
      allow write: if isAuthenticated() &&
        verifyQuestionnaireComplete(request.resource.data) &&
        questionnaireBelongsToUser(request.auth.uid, database, request.resource.data);
    }

    // Don't allow reading/writing to Teams and Orgs.
    match /organizations/{orgID} {
      allow read, write: if false;
    }
    match /teams/{orgID} {
      allow read, write: if false;
    }
  }
}
